const qrcode = require('qrcode-terminal');
const { Client, LocalAuth } = require('whatsapp-web.js');

// Adicionar numeros que ser√£o autorizados utilizar o Chat
const allowNumber = [''];

const client = new Client({
    puppeteer: {
        executablePath: '/usr/bin/google-chrome', // Caminho para o execut√°vel do Chrome para servidor Linux
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
    },
    authStrategy: new LocalAuth()
});

client.on('qr', (qrCode) => {
    qrcode.generate(qrCode, { small: true });
});

client.on('ready', () => {
    console.log('Autenticado com sucesso!');
});

let conversationStates = {};
let userResponses = {};
let timeoutTimer;


// Perguntas que ser√£o enviadas 
const questions = {
    'start': {
        question: 'Ol√°! Eu sou o bot de autoatendimento NOC Unicesumar ü§ñ.\nDe qual cidade voc√™ est√° falando?',
        options: {
            '1': { answer: ' Corumb√°', nextState: 'serviceProblem' },
            '2': { answer: ' Curitiba', nextState: 'serviceProblem' },
            '3': { answer: ' Londrina', nextState: 'serviceProblem' },
            '4': { answer: ' Maring√°', nextState: 'serviceProblem' },
            '5': { answer: ' Ponta Grossa', nextState: 'serviceProblem' },
        },
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'serviceProblem': {
        question: 'Voc√™ esta enfrentando dificuldade em qual servi√ßo ? ',
        options: {
            '1': { answer: ' Internet', nextState: 'internetProblem' },
            '2': { answer: ' Telefone', nextState: 'telephoneProblem' },
            '3': { answer: ' Ambos', nextState: 'bothProblem' },
        },
        invalidOption: ' Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'internetProblem': {
        question: 'Em qual tipo de conex√£o voc√™ est√° enfrentando problemas atualmente ? üåê',
        options: {
            '1': { answer: ' Cabo', nextState: 'otherEquipament' },
            '2': { answer: ' Wi-fi', nextState: 'otherEquipament' },
            '3': { answer: ' Ambas', nextState: 'otherEquipament' }
        },
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'otherEquipament': {
        question: 'Voc√™ consegue acessar a internet de outro equipamento (Computador, celular, ...)?',
        options: {
            '1': { answer: ' Sim', nextState: 'modemIndicatorLights' },
            '2': { answer: ' N√£o', nextState: 'modemIndicatorLights' },
        },
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'modemIndicatorLights': {
        question: 'O seu modem possui alguma luz indicadora de problema ? ',
        options: {
            '1': { answer: ' Sim', nextState: 'validateMedia' },
            '2': { answer: ' N√£o', nextState: 'validateMedia' },
        }
    },
    'validateMedia': {
        question: 'Envie uma foto do aparelho, por gentileza ? üì∏',
        nextState: 'operator',
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'operator': {
        question: 'Qual a operadora esta a falha ? ',
        options: {
            '1': { answer: ' Embratel', nextState: 'analystRouting' },
            '2': { answer: ' Fibercom', nextState: 'analystRouting' },
            '3': { answer: ' Ligga', nextState: 'analystRouting' },
            '4': { answer: ' Oi', nextState: 'analystRouting' },
            '5': { answer: ' Sim Telecom', nextState: 'analystRouting' },
            '6': { answer: ' Vivo', nextState: 'analystRouting' },
            '7': { answer: ' N√£o sei informar', nextState: 'analystRouting' },
        },
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'analystRouting': {
        question: ' Obrigado pelas respostas! Estou encaminhando seu atendimento para um analista. Por favor, aguarde um pouco. ‚è≥',
        nextState: 'pauseChat',
    },
    'telephoneProblem': {
        question: 'Por favor, selecione o problema que voc√™ est√° enfrentando atualmente com as liga√ß√µes ? ü§î',
        options: {
            '1': { answer: ' Realizar', nextState: 'telephoneProblem2' },
            '2': { answer: ' Receber', nextState: 'telephoneProblem2' },
            '3': { answer: ' Ambas', nextState: 'telephoneProblem2' }
        },
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'telephoneProblem2': {
        question: 'Essa dificuldade ocorre com liga√ßoes ? üìû',
        options: {
            '1': { answer: ' Internas', nextState: 'modemIndicatorLights' },
            '2': { answer: ' Externas', nextState: 'modemIndicatorLights' },
            '3': { answer: ' Ambas', nextState: 'modemIndicatorLights' }
        },
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'bothProblem': {
        question: 'Por favor, selecione o problema que voc√™ est√° enfrentando atualmente com as liga√ß√µes ? ü§î',
        options: {
            '1': { answer: ' Realizar', nextState: 'bothProblem2' },
            '2': { answer: ' Receber', nextState: 'bothProblem2' },
            '3': { answer: ' Ambas', nextState: 'bothProblem2' }
        },
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'bothProblem2': {
        question: 'Essa dificuldade ocorre com Liga√ß√µes ? ü§î',
        options: {
            '1': { answer: ' Internas', nextState: 'bothProblem3' },
            '2': { answer: ' Externas', nextState: 'bothProblem3' },
            '3': { answer: ' Ambas', nextState: 'bothProblem3' }
        },
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
    'bothProblem3': {
        question: 'Em rela√ß√£o a internet, qual tipo de conex√£o voc√™ est√° enfrentando problemas atualmente ? ü§î',
        options: {
            '1': { answer: ' Cabo', nextState: 'otherEquipament' },
            '2': { answer: ' Wi-fi', nextState: 'otherEquipament' },
            '3': { answer: ' Ambas', nextState: 'otherEquipament' }
        },
        invalidOption: 'Op√ß√£o n√£o reconhecida. Por favor, escolha uma op√ß√£o v√°lida.',
    },
};

const initializeClient = () => {
    client.on('message', handleMessage);
    client.initialize();
};

const handleMessage = async msg => {
    const userKey = msg.from;

    if (allowNumber.includes(userKey) && msg.body !== null) {
        if (!conversationStates[userKey]) {
            conversationStates[userKey] = "start";
            userResponses[userKey] = [];
            const message = await createMessage(questions['start']);
            await sendMsgWithDelay(userKey, message);
        } else {
            await processMessage(userKey, msg);
            restartTimeout(userKey);
        }
    }
};

async function processMessage(userKey, msg) {
    const currentState = conversationStates[userKey];
    const currentQuestion = questions[currentState];
    // const msgBody = msg.body;
    // const msg = msg;

    // Verifica se o estado atual √© 'pauseChat'
    if (currentState !== 'pauseChat') {
        const newNextState = await checkOption(userKey, msg, currentState);
        // Atualiza o estado atual para o novo estado retornado
        conversationStates[userKey] = newNextState;
    } else {
        processPauseChat(userKey, msg);
    }

    // Verifica novamente se o estado atual √© 'pauseChat' antes de criar a mensagem
    if (conversationStates[userKey] !== 'pauseChat') {

        const nextQuestion = questions[conversationStates[userKey]];
        const nextMessage = await createMessage(nextQuestion);
        await sendMsgWithDelay(userKey, nextMessage);
    }
}

async function checkOption(userKey, msg, currentState) {
    const currentQuestion = questions[currentState];
    const msgBody = msg.body;

    // Verifica se a pergunta atual tem op√ß√µes
    if (currentQuestion.options) {
        const keysAndAnswers = Object.entries(currentQuestion.options).map(([key, value]) => ({
            key: normalizeString(key),
            answer: normalizeString(value.answer),
            nextState: value.nextState
        }));
        const normalizedMsgBody = normalizeString(msgBody);
        const match = keysAndAnswers.find(item =>
            item.key === normalizedMsgBody || item.answer === normalizedMsgBody
        );

        if (match && match.nextState) {
            // Correspond√™ncia encontrada: atualiza o estado e retorna o pr√≥ximo estado
            console.log(`Correspond√™ncia encontrada: ${match.key} - ${match.answer}`);
            console.log(`Novo estado: ${match.nextState}`);
            return match.nextState;
        } else {
            // Nenhuma correspond√™ncia encontrada ou n√£o h√° pr√≥ximo estado
            const errorMessage = currentQuestion.invalidOption;
            console.log('Nenhuma correspond√™ncia encontrada ou n√£o h√° pr√≥ximo estado.');
            console.log(errorMessage);
            await replyWithDelay(msg, errorMessage);
            return currentState;
        }
    } else {
        // Se n√£o houver op√ß√µes, apenas imprime a pergunta e muda para o pr√≥ximo estado
        console.log('Pergunta:', currentQuestion.question);
        const next = currentQuestion.nextState;
        console.log('Novo estado:', next);

        if (currentState === 'validateMedia') {
            if (msg.hasMedia) {
                console.log('M√≠dia recebida. Prosseguindo para o pr√≥ximo estado.');
                return next;
            } else {
                // Se n√£o tiver m√≠dia, emite uma mensagem de erro
                console.log('Nenhuma m√≠dia recebida. Emitindo mensagem de erro.');
                const errorMessage = 'Envie uma m√≠dia para prosseguir.';
                await replyWithDelay(msg, errorMessage);
                return currentState;
            }
        } else {
            return next;
        }
    }
}

async function createMessage(question) {
    const options = question.options || {};
    const message = Object.entries(options).reduce((msg, [key, option]) => {
        return `${msg}${key}. ${option.answer}\n`;
    }, question.question + '\n\n');
    return message.trim();
}

function normalizeString(str) {
    return str
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[\s\-]/g, "");
}

async function processPauseChat(userKey, msg) {
    const notes = ['0', '1', '2', '3', '4', '5'];
    if (notes.includes(msg.body)) {
        await sendMsgWithDelay(msg.from, 'üåü Obrigado pela nota! Estamos aqui para ajudar no que for necess√°rio. N√£o hesite em entrar em contato se precisar de mais assist√™ncia. ü§ù');
        conversationStates[userKey] = '';
    }
}

async function sendMsgWithDelay(to, message) {
    return new Promise(resolve => {
        setTimeout(() => {
            client.sendMessage(to, message);
            resolve();
        }, 1000);
    });
}

async function replyWithDelay(msg, text) {
    return new Promise((resolve) => {
        setTimeout(async () => {
            await msg.reply(text);
            resolve();
        }, 1000);
    });
}

async function restartTimeout(userKey) {
    clearTimeout(timeoutTimer);
    const timeoutDuration = conversationStates[userKey] === "pausarConversa" ? 30000 : 60000;
    timeoutTimer = setTimeout(() => {
        client.sendMessage(userKey, '‚è∞ Desculpe pelo inconveniente! Devido √† inatividade, estamos encerrando o contato. üòî Por favor, sinta-se √† vontade para reiniciar a conversa se desejar continuar com o atendimento. Estamos aqui para ajudar! üîÑ');
        conversationStates[userKey] = '';
    }, timeoutDuration); // 1 minuto em milissegundos
}

initializeClient();
